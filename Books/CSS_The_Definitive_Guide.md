# Notes for [<CSS: The Definitive Guide>](https://www.amazon.com/gp/product/1449393195/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449393195&linkCode=as2&tag=285975600-20&linkId=319482acbe5fb41c5f68365d080b328c)

- Author: Eric A. Meyer, Estelle Weyl
- Version: 4th Edition 2017

## **Ch. 1 CSS and Documents**

### 1.1 A Brief History of (Web) Style

### 1.2 Elements

- 1.2.1 Replaced and Nonreplaced Elements
    - *Replaced elements* are those where the element's content is replaced by something that is not directly represented by document content. For example, The img element is replaced by an image file external to the document itself
    - *Nonreplaced elements* are those whose content is presented by the user agent (generally a browser) inside a box generated by the element itself
- 1.2.2 Element Display Roles
    - *Block-level elements*: generate an element box that fills its parent element's content area and cannot have other elements at its sides
    - *Inline-level elements*: generate an element box within a line of text and do not break up the flow of that line
    - CSS Property: `display` eg. `display: inline;` `display: block;`

### 1.3 Bringing CSS and HTML Together

- 1.3.1 The `<link>` Tag
- 1.3.2 The `<style>` Element
- 1.3.3 The `@import` Directive
    - Just like `<link>`, `@import` can be used to direct the web browser to load an external stylesheet and use its styles in the rendering of the HTML document. The only major difference is in the syntax and placement of the command. As you can see, `@import` is found inside the style container. It must be placed before the other CSS rules or it won't work at all

        ```
        <style type="text/css">
          @import url(style.css);
          h1 {color: gray}
        </style>
        ```

    - Like `<link>`, there can be more than one `@import` statement in a document
    - Unlike `<link>`, the stylesheets of every `@import` directive will be loaded and used
- 1.3.4 HTTP Linking
- 1.3.5 Inline Styles

### 1.4 Stylesheet Contents

- 1.4.1 Markup
- 1.4.2 Rule Structure
- 1.4.3 Vendor prefixing
- 1.4.4 Whitespace Handling
- 1.4.5 CSS Comments

### 1.5 Media Queries

- 1.5.1 Usage
- 1.5.2 Simple Media Queries
- 1.5.3 Media Types
- 1.5.4 Media Descriptors
- 1.5.5 Media Feature Descriptors and Value Types

### 1.6 Feature Queries

### 1.7 Summary

## **Ch. 2 Selectors**

### 2.1 Basic Style Rules

- 2.1.1 Element Selectors
- 2.1.2 Declarations and Keywords

### 2.2 Grouping

- 2.2.1 Grouping Selectors
- 2.2.2 Grouping Declarations
    - Although it is not technically necessary to follow the last declaration of a rule with a semicolon in CSS, it is generally good practice to do so. First, it will keep you in the habit of terminating your declarations with semicolons, the lack of which is one of the most common causes of rendering errors. Second, if you decide to add another declaration to a rule, you won’t have to worry about forgetting to insert an extra semicolon. Third, if you ever use a preprocessor like Sass, trailing semicolons are often required for all declarations. Avoid all these problems—always follow a declaration with a semicolon, wherever the rule appears.
- 2.2.3 Grouping Everything
- 2.2.4 New Elements in Old Browsers

### 2.3 Class and ID Selectors

- 2.3.1 Class Selectors
- 2.3.2 Multiple Classes
- 2.3.3 ID Selectors
- 2.3.4 Deciding Between Class and ID
    - In the real world, browsers don’t always check for the uniqueness of IDs in HTML. That means that if you sprinkle an HTML document with several elements, all of which have the same value for their ID attributes, you’ll probably get the same styles applied to each. This is incorrect behavior, but it happens anyway. Having more than one of the same ID value in a document also makes DOM scripting more difficult, since functions like getElementById() depend on there being one, and only one, element with a given ID value.

### 2.4 Attribute Selectors

- 2.4.1 Simple Attribute Selectors
- 2.4.2 Selection Based on Exact Attribute Value
    - this format requires an exact match for the attribute’s value. Matching becomes an issue when the selector form encounters values that can in turn contain a space-separated list of values (e.g., the HTML attribute class). For example, consider the following markup fragment: `<planet type="barren rocky">Mercury</planet>` The only way to match this element based on its exact attribute value is to write: `planet[type="barren rocky"] {font-weight: bold;}` If you were to write planet[type="barren"], the rule would not match the example markup and thus would fail. This is true even for the class attribute in HTML. Consider the following: `<p class="urgent warning">When handling plutonium, care must be taken to avoid the formation of a critical mass.</p>` To select this element based on its exact attribute value, you would have to write:`p[class="urgent warning"] {font-weight: bold;}` This is not equivalent to the dot-class notation covered earlier, as we will see in the next section. Instead, it selects any p element whose class attribute has exactly the value "urgent warning", with the words in that order and a single space between them. It’s effectively an exact string match.
- 2.4.3 Selection Based on Partial Attribute Values
- 2.4.4 A Particular Attribute Selection Type
    - You may have noticed that I’ve quoted all the attribute values in the attribute selectors. Quoting is required if the value includes any special characters, begins with a dash or digit, or is otherwise invalid as an identifier and needs to be quoted as a string. To be safe, I recommend always quoting attribute values in attribute selectors, even though it is only required to makes strings out of invalid identifiers.
- 2.4.5 The Case Insensitivity Identifier

### 2.5 Using Document Structure

- 2.5.1 Understanding the Parent-Child Relationship
- 2.5.2 Descendant Selectors
- 2.5.3 Selecting Children
- 2.5.4 Selecting Adjacent Sibling Elements
- 2.5.5 Selecting Following Siblings

### 2.6 Pseudo-Class Selectors

- 2.6.1 Combining Pseudo-Classes
- 2.6.2 Structural Pseudo-Classes
    - Selecting the root element `:root`
    - Selecting empty elements `:empty`
    - Selecting unique children `:only-child` `:only-of-type`
    - Selecting first and last children `:first-child` `:last-child`
    - Selecting every nth child `:nth-child(n)`
- 2.6.3 Dynamic Pseudo-Classes
- 2.6.4 UI-State Pseudo-Classes
- 2.6.5 The :target Pseudo-Classes
- 2.6.6 The :lang Pseudo-Classes
- 2.6.7 The Negation Pseudo-Classes

### 2.7 Pseudo-Element Selectors

- Styling the First Letter
- Styling the First Line
- Restrictions on ::first-letter and ::first-line
- Styling (or Creating) Content Before and After Elements

### 2.8 Summary

## Ch. 3 Specificity and the Cascade

## Ch. 4 Values and Units

## Ch. 5 Fonts

## Ch. 6 Text Properties

## Ch. 7 Basic Visual Formatting

## Ch. 8 Padding, Borders, Outlines, and Margins

## Ch. 9 Colors, Backgrounds, and Gradients

## Ch. 10 Floating and Shapes

## Ch. 11 Positioning

## Ch. 12 Flexible Box Layout

## Ch. 13 Grid Layout

## Ch. 14 Table Layout in CSS

## Ch. 15 Lists and Generated Content

## Ch. 16 Transforms

## Ch. 17 Transitions

## Ch. 18 Animation

## Ch. 19 Filters, Blending, Clipping, and Masking

## Ch. 20 Media-Dependent Styles